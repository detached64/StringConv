using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;

namespace StringConv.Generator;

[Generator]
internal class ConverterGenerator : IIncrementalGenerator
{
    private const string StringConverterBaseName = "StringConv.Models.Converters";
    private const string StringConverterFullName = "StringConv.Models.Converters.StringConverter";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<INamedTypeSymbol> classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax c && c.BaseList is not null,
                transform: static (ctx, _) =>
                {
                    ClassDeclarationSyntax classDeclaration = (ClassDeclarationSyntax)ctx.Node;
                    return ctx.SemanticModel.GetDeclaredSymbol(classDeclaration) is INamedTypeSymbol symbol ? symbol : null;
                })
            .Where(static m => m is not null)!;

        IncrementalValuesProvider<INamedTypeSymbol> foundImplementations = classDeclarations
            .Where(classSymbol =>
            {
                if (classSymbol.IsAbstract)
                    return false;

                if (classSymbol.ToDisplayString() == "StringConv.Models.Converters.CharEncodingConverter")
                    return false;

                INamedTypeSymbol baseType = classSymbol.BaseType;
                while (baseType != null)
                {
                    if (baseType.ToDisplayString() == StringConverterFullName)
                    {
                        return true;
                    }
                    baseType = baseType.BaseType;
                }
                return false;
            });

        IncrementalValueProvider<ImmutableArray<INamedTypeSymbol>> collected = foundImplementations.Collect();

        context.RegisterSourceOutput(collected, (spc, source) =>
        {
            if (source.IsDefaultOrEmpty)
            {
                return;
            }

            ImmutableArray<string> classNames = [.. source.Select(s => s.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)).OrderBy(s => s)];

            string sourceCode = GenerateSource(classNames);
            spc.AddSource("StringConverterProvider.g.cs", sourceCode);
        });
    }

    private static string GenerateSource(ImmutableArray<string> converters)
    {
        StringBuilder sb = new();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();
        sb.AppendLine($"namespace {StringConverterBaseName}");
        sb.AppendLine("{");
        sb.AppendLine("    internal static partial class StringConverterProvider");
        sb.AppendLine("    {");
        sb.AppendLine("        private static IEnumerable<StringConverter> LoadConvertersGenerated()");
        sb.AppendLine("        {");
        foreach (string converter in converters)
        {
            sb.AppendLine($"            yield return new {converter}();");
        }
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }
}
